<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>tantivy-insight</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">2.</strong> 索引生成</a></li><li class="chapter-item expanded "><a href="files.html"><strong aria-hidden="true">3.</strong> 索引文件</a></li><li class="chapter-item expanded "><a href="merging.html"><strong aria-hidden="true">4.</strong> Merging Policy</a></li><li class="chapter-item expanded "><a href="term.html"><strong aria-hidden="true">5.</strong> Term</a></li><li class="chapter-item expanded "><a href="postings.html"><strong aria-hidden="true">6.</strong> 倒排索引</a></li><li class="chapter-item expanded "><a href="search.html"><strong aria-hidden="true">7.</strong> 搜索</a></li><li class="chapter-item expanded "><a href="skiplist.html"><strong aria-hidden="true">8.</strong> 跳表</a></li><li class="chapter-item expanded "><a href="fst.html"><strong aria-hidden="true">9.</strong> FST</a></li><li class="chapter-item expanded "><a href="bm25.html"><strong aria-hidden="true">10.</strong> BM25</a></li><li class="chapter-item expanded "><a href="lucene.html"><strong aria-hidden="true">11.</strong> Lucene</a></li><li class="chapter-item expanded "><a href="Q&A.html"><strong aria-hidden="true">12.</strong> Q&amp;A</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">tantivy-insight</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#为什么在有elastic-search的情况下还要tantivy" id="为什么在有elastic-search的情况下还要tantivy">为什么在有Elastic Search的情况下,还要Tantivy?</a></h1>
<ol>
<li>
<p>Tantivy比Lucene快</p>
</li>
<li>
<p>Rust写的有更多的可能性</p>
</li>
</ol>
<p>Rust 写的可以移植到intel SGX中,也可能放到WASM中(写Rust附送WASM)</p>
<h1><a class="header" href="#为什么tantivy比lucene快" id="为什么tantivy比lucene快">为什么tantivy比lucene快?</a></h1>
<p>如果只说tantivy是Rust写的,所以比java快,是不准确的. lucene的移植,比如Rucene,clucene都比lucene慢</p>
<p>真正的原因是:</p>
<p>SIMD</p>
<p>the care given to what should be a static dispatch and what can be a dynamic dispatch</p>
<p>on the indexer side,the data structure is sensibly different</p>
<p>For count on unions, the algorithm is better on tantivy's side</p>
<p>Finally there is a couple of difference in phase queries handling, I don't know if that make s difference to be honest</p>
<h1><a class="header" href="#建立索引" id="建立索引">建立索引</a></h1>
<p>首先放在内存中.当体积达到一定大的时候,就flush到磁盘.还在内存没有flush的时候是不能搜索的,所以tantivy,lucene叫做接近实时,而非绝对实时</p>
<p>flush到磁盘可以是手工的,也可以是自动的.按需求来.</p>
<p>在tantivy-sgx中需要手工调用commit来刷新索引,因为我去掉了对于磁盘的监控</p>
<table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>POSTING</td><td>8.5M</td><td>.idx</td><td>倒排索引</td></tr>
<tr><td>POSTIONS</td><td>1.6G</td><td>.pos</td><td>每个Term在document中的position</td></tr>
<tr><td>TERMS</td><td>60M</td><td>.term</td><td>Term-&gt;TermInfo dictionary. 使用FST</td></tr>
<tr><td>STORE</td><td>4.5G</td><td>.store</td><td>原document.如果Scheme中加了STORE</td></tr>
<tr><td>POSTITIONSSKIP</td><td>9.4M</td><td>.posidx</td><td>todo</td></tr>
<tr><td>FIELDNORMS</td><td>8.5M</td><td>.fieldnorm</td><td>todo</td></tr>
<tr><td>FASTFIELDS</td><td>5byte</td><td>.fast</td><td>空文件</td></tr>
</tbody></table>
<h2><a class="header" href="#tantivy中有时会产生很大的索引文件比如表格中的pos文件那么他是怎么读到内存中的" id="tantivy中有时会产生很大的索引文件比如表格中的pos文件那么他是怎么读到内存中的">Tantivy中,有时会产生很大的索引文件,比如表格中的.pos文件.那么他是怎么读到内存中的?</a></h2>
<p>首先文件用mmap读到内存中,然后转到某个数据结构.</p>
<p>但是转成某个数据结构之后,原始文件还会在缓存中存在.用的是一个HashMap.虽然我不确定HashMap的意义,毕竟把内存搞的很大</p>
<h2><a class="header" href="#postions的作用" id="postions的作用">POSTIONS的作用</a></h2>
<p>.pos是最大的一个文件，但是他其实没有什么用。
只有在词组查询的时候才会用到。</p>
<p>position与positionreader联系紧密。
SegmentPosting里有一个positionreader
但是SegmentPosting中的positionreader只在positions_with_offset里用到过
继续追查position_with_offset 发现用处很少。</p>
<h3><a class="header" href="#如何验证" id="如何验证">如何验证？</a></h3>
<p>用vmtouch
首先把pos文件从内存中释放</p>
<pre><code>vmtouch -ve engines/tantivy-0.13/idx/05547fff51334b478466bd834bb95df6.pos
</code></pre>
<p>然后查看一下，发现确实都释放了。</p>
<pre><code>$ vmtouch -v engines/tantivy-0.13/idx/05547fff51334b478466bd834bb95df6.pos

engines/tantivy-0.13/idx/05547fff51334b478466bd834bb95df6.pos
[                                                            ] 0/6032

           Files: 1
     Directories: 0
  Resident Pages: 0/6032  0/23M  0%
         Elapsed: 0.000701 seconds

</code></pre>
<p>以上的输出表示内存中没有这个pos文件的缓存。</p>
<p>然后我们把query.txt中包含phrase的行都删除掉。我是用vim打开，然后敲</p>
<pre><code>:g/phrase/d
</code></pre>
<p>然后 <code>make bench</code></p>
<p>再 </p>
<pre><code>$ vmtouch -v engines/tantivy-0.13/idx/05547fff51334b478466bd834bb95df6.pos

engines/tantivy-0.13/idx/05547fff51334b478466bd834bb95df6.pos
[                                                oOOO     ooo] 401/6032

           Files: 1
     Directories: 0
  Resident Pages: 401/6032  1M/23M  6.65%
         Elapsed: 0.00083 seconds

</code></pre>
<p>发现只读了一点头部信息，并没有把整个文件都加载到内存。
如果真正使用了pos文件，整个文件都会在内存中，可以自行实验一下。</p>
<h1><a class="header" href="#merging-policy" id="merging-policy">Merging Policy</a></h1>
<p>一个document一开始是一个segment.
成百上千的document就会是成百上千的segment.
搜索的时候,每个segment作为一个独立的单元进行搜索
如果有100个segment,那就有1000个线程在搜索,这显然不行.
大多数时候可以合到只有一个Segment.我们尽可能合并成只有几个Segment.我最多见过7个Segment.
合并的过程称为merge</p>
<p>Merge的时候会使用Merging Policy. Tantivy中只实现一个Merging Policy. 他的工作流程如下:</p>
<ol>
<li>首先如果一个Segment太大,就不管了</li>
<li>找到和Segment差不多大的一些Segment,比如 8 9 10可以考虑合在一起. 100和8 9就不能聚在一起了</li>
<li>如果这一组的Segment有8个,那就合并.比如8个8,就能合并.7个8就不能</li>
</ol>
<hr />
<p>对索引优化并不会提高索引速度.只是能减少打开的文件数量.</p>
<p>优化索引的时机并不是在构建索引时.在构建完索引,并且在将来一段时间内不需要被更改时进行优化最好</p>
<h1><a class="header" href="#term" id="term">Term</a></h1>
<p>title:obama 是一个Term. 表示在title中包含obama</p>
<p>多个Term的组合是查询条件, 比如 title:obama  OR title:president OR body:obama OR body:president </p>
<p>一个Term是个[u8]. 前4个u8(u32),表示Field(title/body). u32-&gt;Field 在Schema中.</p>
<p>Term[5:]表示obama</p>
<p>term会放在fst中,写在硬盘里</p>
<h1><a class="header" href="#postings" id="postings">Postings</a></h1>
<p>也称为Inverted list, posting list</p>
<p>是Term -&gt; [DocId] 的映射</p>
<p>在tantivy中,是 Term -&gt; [(DocId,frequencies)]</p>
<p>The term frequency is the number of occurrences of the term within the document.</p>
<p>In source code, Term-&gt;[(DocId,frequencies);128], which is in postings/serilizer.rs:265 Block struct</p>
<p>Block is used in PostingsSerializer</p>
<p>有3个Trait: Query, Weight, Score</p>
<p>Query是对 搜索pattern解析后返回的抽象. 搜索pattern解析后返回值是 Box<dyn Query></p>
<p>Query负责管理Weight. </p>
<p>Weight负责每一个Segment.查到的数据返回给Query.</p>
<h1><a class="header" href="#每个segment的处理" id="每个segment的处理">每个Segment的处理</a></h1>
<p>首先每个Segment是由7个文件组成的。</p>
<p>以 title:obama 为例</p>
<p>首先对title处理。title成为Field,在Schema中有一个map,会把Field转成u32.这是因为保存在文件的时候，存字符串不太容易，所以都是转成u32的</p>
<p>然后我们要插倒排索引。倒排索引在pos文件里面。在一个大的pos文件里面，根据Field被分割成几部分。
首先找到title的部分。</p>
<p>然后我们要找obama的部分。obama是一个Term，有一个TermInfo描述了Term在Field里的偏移量。这样就能找到obama的倒排索引的内容了</p>
<p>倒排索引是以Block为单位的，每个block里有128个文章和对应的出现频率。 用128是SIMD的要求。</p>
<p>但并不是一个segment只能有128个文章。事实上10000个文章是没有问题的。128篇文章只是一个处理单元。每收集了128篇文章，就保存一次磁盘。
最后尾巴上不够128篇文章也没关系.用0填充就可以了</p>
<p>在实现上，是复用一个Block.这个block有一个is_full方法。 一旦full了，就write to disk,然后clean这个struct,重复使用这一块内存。</p>
<h1><a class="header" href="#skiplist" id="skiplist">SkipList</a></h1>
<p>在倒排索引中使用了跳表.来加速查询.</p>
<p>每个Term建立一个跳表.跳表里存DocId. 可以快速查询一篇文档里面有没有这个Term</p>
<p>跳表只在内存中,不存磁盘.因为没有序列化方法(serde)</p>
<h1><a class="header" href="#fst" id="fst">FST</a></h1>
<p>FST=Trie(前缀压缩)+后缀压缩</p>
<p>FST优化Trie的同时,也带来了新的问题.否则还要Trie干嘛.</p>
<h2><a class="header" href="#fst-vs-trie" id="fst-vs-trie">FST vs Trie</a></h2>
<ol>
<li>Trie只适合英文</li>
<li>FST能压缩前缀和后缀. Trie只能压缩前缀</li>
<li>Trie对插入顺序无所谓,但是FST要求必须按字母顺序插入</li>
<li>FST主要用在放硬盘里,Trie的序列化到硬盘没见过</li>
<li>FST加入之后很难修改/删除.Trie的修改和删除容易一点 </li>
</ol>
<p>FST修改/删除=重新构建一个FST.删除不能简单的做个标注,因为你要考虑不同路径来的都删除了.</p>
<p>https://www.cnblogs.com/bonelee/p/6226185.html</p>
<hr />
<h2><a class="header" href="#用fst能做什么" id="用fst能做什么">用FST能做什么?</a></h2>
<ul>
<li>有序集合</li>
<li>有序dictionary (value需要定义运算符,比如整数的加法)</li>
</ul>
<p>FST与存储相关联.如果只在内存中,不如用无序的hashmap或者有序的BTree.</p>
<p>存储可以是硬盘,socket或者内存.反正是Rust中writable的东西</p>
<hr />
<h2><a class="header" href="#fst-vs-btreesetbtreemap" id="fst-vs-btreesetbtreemap">FST vs BTreeSet,BTreeMap</a></h2>
<p>Rust标准库里有  BTreeSet 和 BTreeMap. 他们是有序的集合和有序的map.</p>
<p>FST也是有序的.那么他们的区别是</p>
<ol>
<li>FST中key只能是byte sequences. 必须能用[u8] 表示. BTreeSet和BTreeMap中key只要能序列化就行</li>
<li>FST中value暂时只能是u64. 顶多支持能定义+的格式比如字符串. BTreeMap没有限制</li>
<li>BTreeSet和BTreeMap的插入,不需要按照顺序.但是FST必须是按顺序插入.不按顺序插入会报错.也就是说FST没有很好的动态扩展性</li>
</ol>
<hr />
<h2><a class="header" href="#fst-vs-gzip" id="fst-vs-gzip">FST vs gzip</a></h2>
<ol>
<li>压缩时间和压缩率上,gzip都比FST好</li>
<li>但是FST能在上面做搜索</li>
</ol>
<hr />
<h2><a class="header" href="#fst-如何压缩后缀的" id="fst-如何压缩后缀的">FST 如何压缩后缀的</a></h2>
<p>首先要求按字母顺序的插入.否则只能重新构建.现在FST的实现也是这样的.</p>
<p>难点在于,一个点从unfinished变成finished, 如何判断相同的状态已经出现过了.</p>
<h3><a class="header" href="#如何判断两个点是不是一样的-" id="如何判断两个点是不是一样的-">如何判断两个点是不是一样的 ?</a></h3>
<ol>
<li>是否同时是终态,或者同时不是终态</li>
<li>所有的儿子是不是一样</li>
<li>去每个儿子的路径上面的字母(如果是map,还是u64),是不是一样</li>
</ol>
<p>只有3个条件都满足,才能合并.</p>
<p>如果点的数量不大,可以一个一个条件去比较. 但如果数量太多,最好能压缩一下状态.FST用了一个cache压缩状态,就是把所有条件都xor起来,变成一个u64.</p>
<hr />
<h2><a class="header" href="#例子" id="例子">例子</a></h2>
<p><img src="./abcdSS.png" alt="abcdSS" /></p>
<p>如上图,插入的是abc 和 abcd 两个单词,就会有两个终止状态.FST中不一定只有一个终止状态.也就是说,如果插入的两个单词有前缀关系,就会出现多个终止态.</p>
<p>FST插入一定要按照字典序,例如必须先插入abc,再插入abcd.</p>
<p>如果先插入了abcd,即下图</p>
<p><img src="./abcd.png" alt="abcd" /></p>
<p>再插入abc,对于状态4来说,就有点尴尬了.一个普通状态要变成终止态?</p>
<hr />
<p>我们再看一个插入顺序的问题,导致发生严重后果的例子.首先我们插入thursday和wednesday.现在的FST是正确的.</p>
<p><img src="./thursday.png" alt="thursday" /></p>
<p>如果我们再插入一个单词 thurs ,变成下图</p>
<p><img src="./thursdaySS.png" alt="thursdaySS" /></p>
<p>副作用是 wednes 也在这个FST中. 这不是我们想要的</p>
<p>我们正确的插入顺序是 thurs thursday wednesday ,FST图应该是这样</p>
<p><img src="./thursdayTT.png" alt="thursdayTT" /></p>
<p>注意S2和q14是不同的两个点.不能捏在一起.</p>
<h2><a class="header" href="#fst-的编程实现" id="fst-的编程实现">FST 的编程实现</a></h2>
<ol>
<li>在现有的FST 中,找到最长前缀.前缀压缩总是安全的,就算路过终态也没关系.终态的点也可以复用.</li>
</ol>
<p>最后一个单词的每一个节点,都是 BuilderNodeUnfinished . BuilderNodeUnfinished 表示这个点还可能有新的儿子节点.只有一个节点,不会在生出新的儿子节点,才可能从后缀开始合并.</p>
<h2><a class="header" href="#原则" id="原则">原则</a></h2>
<ul>
<li>一个点只可能unfinished转成finished,不可能finished转成unfinished</li>
<li>起点总是非终态的。直到全部完成</li>
<li>总有一个终态对象是可以复用的</li>
</ul>
<p>FST的美妙之处在于,虽然没有太刻意的处理前缀,但是前缀还是压缩了.</p>
<h2><a class="header" href="#如何学习fst" id="如何学习fst">如何学习FST</a></h2>
<p>fst-bin 目录提供的二进制可以把fst文件转成graphviz格式,然后可以画出图片.参见 <code>fst -h</code> </p>
<p>如果你想知道某几个输入之后的FST的形状,可以用它画一画.</p>
<h2><a class="header" href="#fst如何序列化" id="fst如何序列化">FST如何序列化</a></h2>
<p>todo 有点绕,不想看了.反正没用serde</p>
<h2><a class="header" href="#fst如果做模糊搜索的levenshteinregex" id="fst如果做模糊搜索的levenshteinregex">FST如果做模糊搜索的(Levenshtein,regex)</a></h2>
<p>todo</p>
<h2><a class="header" href="#tantivy中的fst" id="tantivy中的fst">Tantivy中的FST</a></h2>
<p>tantivy中FST用来存term</p>
<p>tantivy魔改了FST,我还没细看.为什么要魔改,我也不清楚</p>
<h2><a class="header" href="#参考文献" id="参考文献">参考文献</a></h2>
<p>https://blog.burntsushi.net/transducers/</p>
<h1><a class="header" href="#bm25" id="bm25">BM25</a></h1>
<p>todo</p>
<h1><a class="header" href="#lucene" id="lucene">Lucene</a></h1>
<p>这里整理一些我看到的和lucene相关的资料</p>
<table><thead><tr><th>Jargon</th><th>Meaning</th></tr></thead><tbody>
<tr><td>Field</td><td>StringField, TextField and NumericDocValuesField</td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#pattern" id="pattern">Pattern</a></h2>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>java</td><td>默认域包含java项的文档</td></tr>
<tr><td>java unit</td><td>默认域包含java或者unit的文档</td></tr>
<tr><td>java OR unit</td><td>同上</td></tr>
<tr><td>+java +unit</td><td>默认域同时包含java和unit的文档</td></tr>
<tr><td>java AND unit</td><td>同上</td></tr>
<tr><td>title:ant</td><td>title域中包含ant的文档</td></tr>
<tr><td>java~</td><td>与java相似的项的文档,例如lava</td></tr>
<tr><td>java*</td><td>包含与java开头的项的文档,例如javaserver java.net</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#merging-policy-1" id="merging-policy-1">Merging policy</a></h2>
<p>有两种mergy policy.一个根据大小(字节)合并,一种根据文档个数合并.
如果文档大小的方差比较大,建议使用文档大小合并
当然,你也可以自己写Merging policy</p>
<h2><a class="header" href="#compare-with-tantivy" id="compare-with-tantivy">Compare with tantivy</a></h2>
<table><thead><tr><th></th><th>lucene</th><th>tantivy</th></tr></thead><tbody>
<tr><td>音近词</td><td>✅</td><td>❌</td></tr>
<tr><td>形近词</td><td>✅</td><td>❌</td></tr>
<tr><td>自定义排序</td><td>✅</td><td>I don't know</td></tr>
</tbody></table>
<h3><a class="header" href="#音近词" id="音近词">音近词</a></h3>
<p>似乎用处不大</p>
<p>在google搜索中,只有当所有单词都出现拼写错误,因而没有搜索到任何匹配文档的时候,才会检查音近词,否则搜索的结果就太多了</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
